/**
 *  Benedikt Kristinsson, 2010
 *
 *  Tsense Protocol methods. Written in C++ to ensure comptability with Arduino
 *  Wiring, but made to be compilable with gcc and g++.
 *
 *  For documentation, please see ldsswiki.ru.is
 *
 *    This file is part of the Trusted Sensors Research Project (TSense).
 *
 *  TSense is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *
 *  TSense is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *
 *  You should have received a copy of the GNU General Public License
 *  along with the TSense code.  If not, see <http://www.gnu.org/licenses/>.
 *
 */

#include "protocol.h"

/*
  TODO: Don't use a hardcoded IV
 */
byte_ard IV[] = {
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 
};

/**
 *
 * pack_idresponse()
 *
 * Writes the byte stream for the first step of the authentication and key
 * exchange steps. This is the packet generated
 *
 * Name:    Msg Code  |  Public ID   | Ciphertext                   | Cmac
 * Bytes:   1         |  6 (ID_SIZE) | 16                           | 16 (BLOCK_BYTE_SIZE)
 * Data:    0x10      |              | Public ID, Nonce, Padding    |
 *
 * Total bytecount: 39 bytes
 */
void pack_idresponse(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void *pBuffer)
{
  byte_ard crypt_buff[IDMSG_CRYPTSIZE];
  byte_ard cmac_buff[IDMSG_CRYPTSIZE];
  byte_ard temp[ID_SIZE + NONCE_SIZE];
  
  for (u_int32_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  for(u_int32_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE + i] = ( msg->nonce >> (i*8) ) & 0xFF;
  }

  // Encrypt-then-MAC (Bellare and Namprempre)
  CBCEncrypt((void*)temp, (void*) crypt_buff, (ID_SIZE+NONCE_SIZE),
             AUTOPAD, pKeys, (const u_int16_ard*)IV);

  // CMac the crypted ID and Nonce. 
  aesCMac(pCmacKeys, crypt_buff, IDMSG_CRYPTSIZE, cmac_buff);

  byte_ard* cBuffer = (byte_ard*)pBuffer;
  
  // First byte is the msg type. If longer than one byte, add loop.
  //cBuffer[0] = msg->msgtype;
  cBuffer[0] = MSG_T_GET_ID_R;
  msg->msgtype = MSG_T_GET_ID_R;

  // This will strip off the null char wich isn't crypted.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[i + MSGTYPE_SIZE] = msg->pID[i];
  }
  // Add the ciphertext behind the msgtype and plaintext id
  for (u_int32_ard i = 0; i <  IDMSG_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = crypt_buff[i];
  }

  // Add the CMac behind the msgtype, plaintext id and E(Public ID, Nonce)
  for (u_int32_ard j = 0; j < IDMSG_CRYPTSIZE; j++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + IDMSG_CRYPTSIZE + j] = cmac_buff[j];
  }
}

/**
 * unpack_idresponse()
 *
 * Reads a bytestream generated by pack_idresponse() and reads the values
 * to a struct message such that:
 *
 *    Name       | Summary                | Data
 *    -------------------------------------------
 *    msgtype    | Message type           | 0x10 
 *    pID        | Public ID              |
 *    ciphertext | The ciphertext.        |
 *    nonce      | The nonce              |
 *    cmac       | Cmac of the ciphertext | 
 *    
 */
void unpack_idresponse(void* pStream, const u_int32_ard* pKeys,
                       struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  
  // First MSGTYPE_SIZE (1) bytes is msgcode. Assumes one byte, no loop.
  msg->msgtype = cStream[0];

  byte_ard plain_buff[IDMSG_CRYPTSIZE];

  // Get the ciphertext. 
  for(u_int16_ard i = 0; i < IDMSG_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }

  // Decipher
  CBCDecrypt((void*)msg->ciphertext, (void*)plain_buff, IDMSG_CRYPTSIZE, pKeys,
             (const u_int16_ard*)IV);

  // Get the ciphered public id (now deciphered) into the stuct and append \0
  for(u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = plain_buff[i];
  }
  //msg->pID[ID_SIZE] = '\0';

  // Get the nonce into the struct, cast to int again. 
  msg->nonce=0;
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    msg->nonce += (plain_buff[ID_SIZE+i] << (i*8));
  }

  // Get the cmac into the struct.
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    //msg->cmac[i] = plain_buff[ID_SIZE+NONCE_SIZE+i];
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + IDMSG_CRYPTSIZE + i];
  }
}

/**
 * pack_keytosink()
 *
 * The authentication server uses this method to create a packet delivering
 * the session key both to the sensor and the sink. The sink then relays the
 * Ciphertex to the client (which then will pass it on to the sensor)
 *
 * Name:     Msg Code | Public ID   | Session Key   | Renewal timer  | Ciphertext | CMAC
 * Bytes:    1        | 6 (ID_SIZE) | 16 (KEY_BYTES)| 2 (NONCE_SIZE) | 32         | 16
 * Data:     0x11     |             |               |                |            |
 *
 * Total bytecount: 73 bytes
 *
 * Ciphertext (was too long to fit above)
 * Name:    Nonce  |  Session key | Renewal timer | Padding
 * Bytes:   2      |  16          | 2             | 12
 *
 * Ciphertext bytecount: 32
 */

void pack_keytosink(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void *pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  msg->msgtype = MSG_T_KEY_TO_SINK;
  cBuffer[0] = MSG_T_KEY_TO_SINK;

  // NEW: Place the sensor ID in the message.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+i] = msg->pID[i];
  }
  
  // Place the key in the "plaintext" to the sink. (SSLed)
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+i] = msg->key[i];
  }

  // t_ST, expiration time. u_int32
  byte_ard* pTimer = (byte_ard*)&msg->renewal_timer;
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+KEY_BYTES+i] = pTimer[i];
  }

  // Create the buffer that is to be ciphered
  byte_ard temp[NONCE_SIZE+KEY_BYTES+TIMER_SIZE];
  byte_ard cipher_buff[KEYTOSINK_CRYPTSIZE];

  for(u_int32_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[i] = ( msg->nonce >> (i*8) ) & 0xFF;
  }
  
  // Key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    temp[NONCE_SIZE+i] = msg->key[i];
  }
  //Timer (pointer declartion above)
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[NONCE_SIZE+KEY_BYTES+i] = pTimer[i];
  }

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff, (NONCE_SIZE + ID_SIZE + KEY_BYTES + TIMER_SIZE),
             AUTOPAD, pKeys, (const u_int16_ard*)IV);
  aesCMac(pCmacKeys, cipher_buff, KEYTOSINK_CRYPTSIZE, msg->cmac);

  // Put the cipherstuff into the buffer
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + KEY_BYTES + TIMER_SIZE + i] = cipher_buff[i];
  }

  // cmac 
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+KEY_BYTES+TIMER_SIZE+KEYTOSINK_CRYPTSIZE+i] = msg->cmac[i];
  }
}

/**
 * unpack_keytosink()
 *
 * This reads the bytestream generated by pack_keytosink() into a message struct. It
 * does not require a key schedule since the ciphertex is ciphered with a key that
 * the sink is not supposed to have. The struct will look like this:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------
 *    msgtype       | The message type code            | 0x11
 *    key           | The session key                  |
 *    renewal_timer | Key renewal timer                |
 *    ciphertext    | The ciphertext (to be forwarded) |
 *    cmac          | A cmac of the ciphertext         |
 *   
 */
 

void unpack_keytosink(void *pStream, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  // Assumes one byte for msgtype
  msg->msgtype = cStream[0];

  // NEW: The ID is here .
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = cStream[MSGTYPE_SIZE + i];
  }
  
  // Key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->key[i] = cStream[MSGTYPE_SIZE+ID_SIZE+i];
  }

  // Timer
  byte_ard* temp = (byte_ard*)malloc(TIMER_SIZE);
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[i] = cStream[MSGTYPE_SIZE + ID_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*temp;
  free(temp);

  // Since this method unpacks the stream on the Sink, it cannot decipher
  // the ciphertext. (Thus, it is missing the pKey pointer) The Ciphertext
  // will be stored in the struct and will be forwarded to the client and
  // sensor. The Hash is also useless for the sink and is forwarded.

  for(u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + KEY_BYTES + ID_SIZE + TIMER_SIZE + i];
  }
  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + KEY_BYTES + ID_SIZE + TIMER_SIZE + KEYTOSINK_CRYPTSIZE + i];
  }
  
}

/**
 * pack_keytosens()
 *
 * This method does not require a key schedule either. It reads the struct generated
 * by unpack_keytosink(), and takes the ciphertext and cmac and writes it to a bytestream.
 * It is intended to forward the ciphered text to the client. It is assumed that the sink
 * has no means of reading the ciphertext.
 * 
 * Name:     Msg Code | Ciphertext                              | CMAC
 * Bytes:    1        | 32                                      | 16
 * Data:     0x11     | Nonce, Session key, Renewal timer, Pad  |
 *
 * Total bytecount: 49 bytes
 */

void pack_keytosens(struct message* msg, void *pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_KEY_TO_SENSE;
  msg->msgtype = MSG_T_KEY_TO_SENSE;

  // The ciphertext containing the Nonce, key and Timer. 
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->ciphertext[i];
  }
  // The hash
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + KEYTOSINK_CRYPTSIZE + i] = msg->cmac[i];
  }
}

/**
 * unpack_keytosens()
 *
 * Reads the bytestream generated by pack_keytosense(). Intended to run on the sensor
 * which has the key schedule neccesary to decipher the ciphertext. Data is read
 * to a message struct:
 *
 *    Name          | Summary                          | Data
 *    --------------------------------------------------------
 *    msgtype       | Message type code                | 0x11
 *    nonce         | Nonce from A                     |
 *    key           | The session key                  |
 *    renewal_timer | The key renewal timer            |
 *    ciphertext    | Ciphertext as read from stream   |
 *    cmac          | CMAC as read from stream         |
 */

void unpack_keytosens(void *pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  msg->msgtype = cStream[0];

  // Extract the ciphertext
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + i];
  }
  //Extract the hash
  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + (KEYTOSINK_CRYPTSIZE) + i];
  }
  byte_ard plainbuff[KEYTOSINK_CRYPTSIZE];
    
  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, KEYTOSINK_CRYPTSIZE,
             pKeys, (const u_int16_ard*)IV);

  // 1 - nonce
  msg->nonce=0;
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    msg->nonce += plainbuff[i]<<(i*8);
  }

  // 2 - key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->key[i] = plainbuff[NONCE_SIZE + i];
  }
  
  // 3 - timer
  byte_ard timertemp[TIMER_SIZE];
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    timertemp[i] = plainbuff[NONCE_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*timertemp;
}

/**
 * pack_rekey()
 *
 * Packs a request for rekeying. It is also used to let the sink know that the original
 * session key was delivered, having the MSG typecode 0x31. When used for regular
 * re-keying request, the typecode is set to 0x30.
 *
 * Name:     Msg Code  | Public ID  | Ciphertext                | Cmac   
 * Bytes:    1         | 6 (ID_SIZE)| 16                        | 16
 * Data:     0x31/0x30 |            | Public ID, Nonce, Padding |
 *
 * Total bytecount: 39
 */
void pack_rekey(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  byte_ard* cBuffer = (byte_ard*) pBuffer;
  // MSGTYPE
  if (msg->msgtype == MSG_T_REKEY_HANDSHAKE)
  {
    cBuffer[0] = msg->msgtype;
  }
  else
  {
    msg->msgtype = MSG_T_REKEY_REQUEST;
  }
  
  // T (Public ID)
  for (u_int16_ard i = 0; i < ID_SIZE; i ++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->pID[i];
  }

  // Create the ciphered packet
  // ID
  byte_ard temp[ID_SIZE + NONCE_SIZE];
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  // Nonce
  for(u_int32_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE+i] = ( msg->nonce >> (i*8) ) & 0xFF;
  }

  byte_ard cipher_buff[REKEY_CRYPTSIZE];

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff, (ID_SIZE + NONCE_SIZE), AUTOPAD,
             pKeys, (const u_int16_ard*)IV);

  // Stick it in the buffer
  for (u_int16_ard i = 0; i < REKEY_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = cipher_buff[i];
  }

  // CMac
  aesCMac(pCmacKeys, cipher_buff, REKEY_CRYPTSIZE, msg->cmac);
  // Stick it in the buffer
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + REKEY_CRYPTSIZE + i] = msg->cmac[i];
  }
  
}
/**
 * unpack_rekey()
 *
 * Unpacks the re-keying request. Note that pack_rekey() is also used to let the sink know
 * that the original session key was delivered. The MSG typecode used for this is 0x31.
 * Otherwise, regular rekeying requests, use the typecode 0x30.
 *
 * The populated struct:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------------
 *    msgtype       | Message type code                | 0x31 or 0x30
 *    ciphertext    | Ciphertext as read from stream   |
 *    cmac          | CMAC as read from stream         |
 *    pID           | Public ID                        |
 *    nonce         | Nonce                            |
 *
 */
void unpack_rekey(void* pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  msg->msgtype = cStream[0];

  // The ID is only extacted from the ciphertext

  // Extract the ciphertext
  for (u_int16_ard i = 0; i < REKEY_CRYPTSIZE; i ++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }
  // Extract the cmac
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + REKEY_CRYPTSIZE + i];
  }

  // Decipher
  byte_ard plainbuff[REKEY_CRYPTSIZE];
  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, REKEY_CRYPTSIZE,
             pKeys, (const u_int16_ard*)IV);

  // Extract the ID for the ciphertext
  for (u_int16_ard i = 0; i < ID_SIZE; i ++)
  {
    msg->pID[i] = plainbuff[i];
  }
  msg->pID[ID_SIZE] = '\0';

  // Extract the Nonce from the ciphertext
  msg->nonce=0;
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    msg->nonce += (plainbuff[ID_SIZE+i] << (i*8));
  }
}

/**
 * pack_newkey()
 *
 * The method intended for the Sink to send the new key to the sensor.
 *
 * Name:   MSG Code | Ciphertext                                                  | CMAC    
 * Bytes:  1        | 32                                                          | 16
 * Data:   0x32     | Public ID, Nonce, Rand key material, Renewal timer, Padding |
 *
 * Total bytecount: 49 bytes
 */

void pack_newkey(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_REKEY_RESPONSE;
  msg->msgtype = MSG_T_REKEY_RESPONSE;
  
  for(u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->pID[i];
  }

  // Construct the ciphertext
  byte_ard temp[ID_SIZE + NONCE_SIZE + KEY_BYTES + TIMER_SIZE];
  
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  
  for(u_int32_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE+i] = ( msg->nonce >> (i*8) ) & 0xFF;
  }
  
  for(u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    temp[ID_SIZE + NONCE_SIZE + i] = msg->rand[i];
  }
  
  byte_ard* temp_timer = (byte_ard*)&msg->renewal_timer;
  for(u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[ID_SIZE + NONCE_SIZE + KEY_BYTES + i] = temp_timer[i];
  }

  byte_ard cipher_buff[NEWKEY_CRYPTSIZE];

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff,
             (ID_SIZE+NONCE_SIZE+KEY_BYTES+TIMER_SIZE), AUTOPAD,
             pKeys, (const u_int16_ard*)IV);
  // Stick it in the buffer
  for (u_int16_ard i = 0; i < NEWKEY_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = cipher_buff[i];
  }

  // CMac
  aesCMac(pCmacKeys, cipher_buff, NEWKEY_CRYPTSIZE, msg->cmac);

  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + NEWKEY_CRYPTSIZE + i] = msg->cmac[i];
  }
  
}

/**
 * unpack_newkey()
 *
 * Unpacks the new session key (following rekeying) at the sensor.
 * Populated struct:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------------
 *    msgtype       | Message type code                | 0x32
 *    ciphertext    | The ciphertext from stream       |
 *    cmac          | The CMAC from stream             |
 *    pID           | The public ID                    |
 *    nonce         | A nonce from S                   |
 *    rand          | The new key material             |
 *    renewal_timer | The key renewal timer            |
 */

void unpack_newkey(void* pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;

  msg->msgtype = cStream[0];

  // Skip the ID sent in plaintext and grab the cipherstream
  for (u_int32_ard i = 0; i < NEWKEY_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }

  byte_ard plainbuff[NEWKEY_CRYPTSIZE];

  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, NEWKEY_CRYPTSIZE, pKeys,
             (const u_int16_ard*)IV);

  // Cipertext part 1 - ID
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = plainbuff[i];
  }
  
  // Ciphertext part 2 - Nonce
  msg->nonce=0;
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    msg->nonce += (plainbuff[ID_SIZE+i] << (i*8));
  }

  // Ciphertext part 3 - Random
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->rand[i] = plainbuff[ID_SIZE + NONCE_SIZE + i];
  }

  // Ciphertext part 4 - Timer
  byte_ard* temp_timer = (byte_ard*)malloc(TIMER_SIZE);
  for(u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp_timer[i] = plainbuff[ID_SIZE + NONCE_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*temp_timer;
  free(temp_timer);

  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + NEWKEY_CRYPTSIZE + i];
  }
}

/**
 * pack_data()
 * 
 * Packs the measurment data collected by the tsensor. Right now,
 * data is assumed to reside inside a byte_ard array.
 *
 * Name:    MSG Code | Cipher Len | Pub ID | Ciphertext                                            | Cmac 
 * Bytes:   1        | 1          | 6      | ID: 6, Msg Time: 4, Buffer length: 1, Data: Varies    | 16
 * Data:    0x01     |            |        | Public ID, Msg Time, Buffer length, Data              |      
 */

void pack_data(struct data* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  /**
   * Msg type
   */
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_DATA_SEND;

  /**
   * NOTE: Here we use integer division to figure out how many blocks
   * we need for the ciphertext. In future versions every method in
   * the Tsense protocol will use this method instead of the retarded
   * constants.
   *
   * The +1's is for the the two length indicators. One is on the
   * ciphered stream, indicating the length of the buffer that holds
   * the measurment data and the other one is on the plaintext part
   * indidating how long the crypto part of the packet is.
   */
  
  u_int16_ard plainsize = ID_SIZE + MSGTIME_SIZE + 1 + (u_int16_ard) msg->data_len;
  // Since cipher_len is always going to be congruent to 16 in modulus 16, we can
  // use it to indicate much larger ciphertext then 127 if we use that fact. 
  msg->cipher_len = (1 + (plainsize/BLOCK_BYTE_SIZE)) * BLOCK_BYTE_SIZE;
  cBuffer[MSGTYPE_SIZE] = msg->cipher_len;

  /**
   * Sink needs the device ID to look up the encryption key.
   */
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + 1 + i] = msg->id[i];
  }

  /**
   * Malloc is needed because we don't know the exact size
   */
  byte_ard* plaintext = (byte_ard*)malloc(plainsize);

  // Populate plaintext.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    plaintext[i] = msg->id[i];
  }
  byte_ard* temp_msgtime = (byte_ard*)&msg->msgtime;
  for (u_int16_ard i = 0; i < MSGTIME_SIZE; i++)
  {
    plaintext[ID_SIZE + i] = temp_msgtime[i];
  }
  // One byte - no loop
  plaintext[ID_SIZE + MSGTIME_SIZE] = msg->data_len;

  // Data
  for(u_int16_ard i = 0; i < (u_int16_ard)msg->data_len; i++)
  {
    plaintext[ID_SIZE + MSGTIME_SIZE + 1 + i] = msg->data[i];
  }

  byte_ard cipher_buff[(u_int16_ard)msg->cipher_len];

  CBCEncrypt((void*)plaintext, (void*)cipher_buff, plainsize, AUTOPAD,
             pKeys, (const u_int16_ard*)IV);
  free(plaintext);
  aesCMac(pCmacKeys, cipher_buff, (u_int16_ard)msg->cipher_len, msg->cmac);

  // Stick it in the buffer
  for(u_int16_ard i = 0; i < (u_int16_ard)msg->cipher_len; i++)
  {
    // +1 to accomendate for the crypto length indicator. 
    cBuffer[MSGTYPE_SIZE + 1 + ID_SIZE + i] = cipher_buff[i];
  }

  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + 1 + ID_SIZE + (int16_ard)msg->cipher_len + i] = msg->cmac[i];
  }
}

/**
 * unpack_data()
 *
 * Reads bytestream from pack_data(). Retrieves the ciphered-and-maced
 * measurment data with the session key. Runs on a regular
 * architecture so wasting ram here is ok.
 *
 * NOTE: Does malloc() on msg->ciphertext and msg->data !
 *
 *    Name          | Summary                            | Data
 *    ------------------------------------------------------------------
 *    msgtype       | 1-byte message code                | 0x01
 *    id            | 6-byte public id (from ciphertext) |
 *    msgtime       | 4-byte unix time in u_int          |
 *    data_len      | 1-byte denotes length of data      |
 *    cipher_len    | 1-byte denotes length of ciphertext|
 *    data          | Data itself. data-len bytes.       |
 *    ciphertext    | Ciphertext read. cipher-len bytes  |
 *    cmac          | The CMAC. 
 *
 */

void unpack_data(void* pStream, const u_int32_ard* pKeys, struct data* msg)
{

  byte_ard* cStream = (byte_ard*)pStream;
  
  msg->msgtype = cStream[0];
  msg->cipher_len = cStream[1];

  // Store the cipher length in a usigned 16-bit int so we don't have to typecast
  // all the time.
  u_int16_ard cipherlen = (u_int16_ard)msg->cipher_len;
  
  // NOTE: Malloc, Needs to be set free!!
  msg->ciphertext = (byte_ard*)malloc(cipherlen);

  // Read the ciphertext
  for (u_int16_ard i = 0; i < cipherlen; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + 1 + ID_SIZE + i]; /// ERROR MISSING i
  }

  // .. and cmac
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + 1 + ID_SIZE + cipherlen + i];
  }

  // Decrypt
  // Malloc, is free'd in the end of unpack_data()
  byte_ard* plainbuff = (byte_ard*)malloc(cipherlen);

  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, cipherlen, pKeys,
           (const u_int16_ard*)IV);

  // ID
  for (u_int16_ard i = 0; i < ID_SIZE; i ++)
  {
    msg->id[i] = plainbuff[i];
  }

  // Msg time (Unix time)
  // Malloc, free'd a few lines below
//  byte_ard* temp_msgtime = (byte_ard*)malloc(MSGTIME_SIZE);
  msg->msgtime=0;
  for(u_int16_ard i = 0; i < MSGTIME_SIZE; i++)
  {
    //temp_msgtime[i] = plainbuff[ID_SIZE + i];
	msg->msgtime += ( plainbuff[ID_SIZE+i] << (i*8) );
  }
  //msg->msgtime = (u_int32_ard)*temp_msgtime;
  //free(temp_msgtime);

  // Buffer length
  msg->data_len = plainbuff[ID_SIZE + MSGTIME_SIZE];
  u_int16_ard datalen = (u_int16_ard)msg->data_len;
  
  // NOTE: msg->data is malloced. NEEDS TO BE SET FREE 
  msg->data = (byte_ard*)malloc(datalen);
  
  // Data
  for(u_int16_ard i = 0; i < datalen; i++)
  {
    msg->data[i] = plainbuff[ID_SIZE + MSGTIME_SIZE + 1 + i];
  }
  
  free(plainbuff);
}

/**
 * unpack_data_getid() is a small utility method for the sink to
 * scrape the public id from the bytestream since it cannot run
 * unpack_data() without the key schedule and it cannot determine
 * what key schedule to run without the id.
 *
 * See the documentation for pack_data() on how the bytestream is
 * ordered. 
 */

void unpack_data_getid(void* pStream, void* pID)
{
  byte_ard* cStream = (byte_ard*)pStream;
  byte_ard* cID = (byte_ard*)cStream;

  // No buffer overflow. 
  for(u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cID[i] = cStream[MSGTYPE_SIZE + 1 + i];
  }
}
