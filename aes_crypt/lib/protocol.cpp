/**
   Benedikt Kristinsson, 2010

   (GPL here)

   Tsense Protocol methods. Written in C++ to ensure comptability with Arduino
   Wiring, but made to be compilable with gcc and g++.

   For documentation, please see ldsswiki.ru.is

 */

#include "protocol.h"

/*
  TODO: Don't use a hardcoded IV
 */
byte_ard IV[] = {
  0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30, 0x30 
};

/**
 *
 * pack_idresponse()
 *
 * Writes the byte stream for the first step of the authentication and key
 * exchange steps. This is the packet generated
 *
 * Name:    Msg Code  |  Public ID   | Ciphertext                   | Cmac
 * Bytes:   1         |  6 (ID_SIZE) | 16                           | 16 (BLOCK_BYTE_SIZE)
 * Data:    0x10      |              | Public ID, Nonce, Padding    |
 *
 * Total bytecount: 39 bytes
 */
void pack_idresponse(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void *pBuffer)
{
  byte_ard crypt_buff[IDMSG_CRYPTSIZE];
  byte_ard cmac_buff[IDMSG_CRYPTSIZE];
  byte_ard temp[ID_SIZE + NONCE_SIZE];
  byte_ard* pNonce = (byte_ard*)&msg->nonce;
  
  for (u_int32_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  for(u_int32_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE + i] = pNonce[i];
  }

  // Encrypt-then-MAC (Bellare and Namprempre)
  CBCEncrypt((void*)temp, (void*) crypt_buff, (ID_SIZE+NONCE_SIZE),
             AUTOPAD, pKeys, (const u_int16_ard*)IV);

  // CMac the crypted ID and Nonce. 
  aesCMac(pCmacKeys, crypt_buff, IDMSG_CRYPTSIZE, cmac_buff);

  byte_ard* cBuffer = (byte_ard*)pBuffer;
  
  // First byte is the msg type. If longer than one byte, add loop.
  //cBuffer[0] = msg->msgtype;
  cBuffer[0] = MSG_T_GET_ID_R;
  msg->msgtype = MSG_T_GET_ID_R;

  // This will strip off the null char wich isn't crypted.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[i + MSGTYPE_SIZE] = msg->pID[i];
  }
  // Add the ciphertext behind the msgtype and plaintext id
  for (u_int32_ard i = 0; i <  IDMSG_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = crypt_buff[i];
  }

  // Add the CMac behind the msgtype, plaintext id and E(Public ID, Nonce)
  for (u_int32_ard j = 0; j < IDMSG_CRYPTSIZE; j++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + IDMSG_CRYPTSIZE + j] = cmac_buff[j];
  }
}

/**
 * unpack_idresponse()
 *
 * Reads a bytestream generated by pack_idresponse() and reads the values
 * to a struct message such that:
 *
 *    Name       | Summary                | Data
 *    -------------------------------------------
 *    msgtype    | Message type           | 0x10 
 *    pID        | Public ID              |
 *    ciphertext | The ciphertext.        |
 *    nonce      | The nonce              |
 *    cmac       | Cmac of the ciphertext | 
 *    
 */
void unpack_idresponse(void* pStream, const u_int32_ard* pKeys,
                       struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  
  // First MSGTYPE_SIZE (1) bytes is msgcode. Assumes one byte, no loop.
  msg->msgtype = cStream[0];

  byte_ard plain_buff[IDMSG_CRYPTSIZE];

  // Get the ciphertext. 
  for(u_int16_ard i = 0; i < IDMSG_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }

  // Decipher
  CBCDecrypt((void*)msg->ciphertext, (void*)plain_buff, IDMSG_CRYPTSIZE, pKeys,
             (const u_int16_ard*)IV);

  // Get the ciphered public id (now deciphered) into the stuct and append \0
  for(u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = plain_buff[i];
  }
  //msg->pID[ID_SIZE] = '\0';

  // Get the nonce into the struct, cast to int again. 
  byte_ard* temp = (byte_ard*)malloc(NONCE_SIZE);
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[i] = plain_buff[ID_SIZE+i];
  }
  msg->nonce = (u_int16_ard)*temp;
  free(temp);

  // Get the cmac into the struct.
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    //msg->cmac[i] = plain_buff[ID_SIZE+NONCE_SIZE+i];
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + IDMSG_CRYPTSIZE + i];
  }
}

/**
 * pack_keytosink()
 *
 * The authentication server uses this method to create a packet delivering
 * the session key both to the sensor and the sink. The sink then relays the
 * Ciphertex to the client (which then will pass it on to the sensor)
 *
 * Name:     Msg Code | Public ID   | Session Key   | Renewal timer  | Ciphertext | CMAC
 * Bytes:    1        | 6 (ID_SIZE) | 16 (KEY_BYTES)| 2 (NONCE_SIZE) | 32         | 16
 * Data:     0x11     |             |               |                |            |
 *
 * Total bytecount: 73 bytes
 *
 * Ciphertext (was too long to fit above)
 * Name:    Nonce  |  Session key | Renewal timer | Padding
 * Bytes:   2      |  16          | 2             | 12
 *
 * Ciphertext bytecount: 32
 */

void pack_keytosink(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void *pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  msg->msgtype = MSG_T_KEY_TO_SINK;
  cBuffer[0] = MSG_T_KEY_TO_SINK;

  // NEW: Place the sensor ID in the message.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+i] = msg->pID[i];
  }
  
  // Place the key in the "plaintext" to the sink. (SSLed)
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+i] = msg->key[i];
  }

  // t_ST, expiration time. u_int32
  byte_ard* pTimer = (byte_ard*)&msg->renewal_timer;
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+KEY_BYTES+i] = pTimer[i];
  }

  // Create the buffer that is to be ciphered
  byte_ard temp[NONCE_SIZE+KEY_BYTES+TIMER_SIZE];
  byte_ard cipher_buff[KEYTOSINK_CRYPTSIZE];

  byte_ard* pNonce = (byte_ard*)&msg->nonce;
  // N_T
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[i] = pNonce[i];
  }
  
  // Key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    temp[NONCE_SIZE+i] = msg->key[i];
  }
  //Timer (pointer declartion above)
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[NONCE_SIZE+KEY_BYTES+i] = pTimer[i];
  }

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff, (NONCE_SIZE + ID_SIZE + KEY_BYTES + TIMER_SIZE),
             AUTOPAD, pKeys, (const u_int16_ard*)IV);
  aesCMac(pCmacKeys, cipher_buff, KEYTOSINK_CRYPTSIZE, msg->cmac);

  // Put the cipherstuff into the buffer
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + KEY_BYTES + TIMER_SIZE + i] = cipher_buff[i];
  }

  // cmac 
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE+ID_SIZE+KEY_BYTES+TIMER_SIZE+KEYTOSINK_CRYPTSIZE+i] = msg->cmac[i];
  }
}

/**
 * unpack_keytosink()
 *
 * This reads the bytestream generated by pack_keytosink() into a message struct. It
 * does not require a key schedule since the ciphertex is ciphered with a key that
 * the sink is not supposed to have. The struct will look like this:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------
 *    msgtype       | The message type code            | 0x11
 *    key           | The session key                  |
 *    renewal_timer | Key renewal timer                |
 *    ciphertext    | The ciphertext (to be forwarded) |
 *    cmac          | A cmac of the ciphertext         |
 *   
 */
 

void unpack_keytosink(void *pStream, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  // Assumes one byte for msgtype
  msg->msgtype = cStream[0];

  // NEW: The ID is here .
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = cStream[MSGTYPE_SIZE + i];
  }
  
  // Key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->key[i] = cStream[MSGTYPE_SIZE+ID_SIZE+i];
  }

  // Timer
  byte_ard* temp = (byte_ard*)malloc(TIMER_SIZE);
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[i] = cStream[MSGTYPE_SIZE + ID_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*temp;
  free(temp);

  // Since this method unpacks the stream on the Sink, it cannot decipher
  // the ciphertext. (Thus, it is missing the pKey pointer) The Ciphertext
  // will be stored in the struct and will be forwarded to the client and
  // sensor. The Hash is also useless for the sink and is forwarded.

  for(u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + KEY_BYTES + ID_SIZE + TIMER_SIZE + i];
  }
  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + KEY_BYTES + ID_SIZE + TIMER_SIZE + KEYTOSINK_CRYPTSIZE + i];
  }
  
}

/**
 * pack_keytosens()
 *
 * This method does not requier a key schedule either. It reads the struct generated
 * by unpack_keytosink(), and takes the ciphertext and cmac and writes it to a bytestream.
 * It is intended to forward the ciphered text to the client. It is assumed that the sink
 * has no means of reading the ciphertext.
 * 
 * Name:     Msg Code | Ciphertext                              | CMAC
 * Bytes:    1        | 32                                      | 16
 * Data:     0x11     | Nonce, Session key, Renewal timer, Pad  |
 *
 * Total bytecount: 49 bytes
 */

void pack_keytosens(struct message* msg, void *pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_KEY_TO_SENSE;
  msg->msgtype = MSG_T_KEY_TO_SENSE;

  // The ciphertext containing the Nonce, key and Timer. 
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->ciphertext[i];
  }
  // The hash
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + KEYTOSINK_CRYPTSIZE + i] = msg->cmac[i];
  }
}

/**
 * unpack_keytosens()
 *
 * Reads the bytestream generated by pack_keytosense(). Intended to run on the sensor
 * which has the key schedule neccesary to decipher the ciphertext. Data is read
 * to a message struct:
 *
 *    Name          | Summary                          | Data
 *    --------------------------------------------------------
 *    msgtype       | Message type code                | 0x11
 *    nonce         | Nonce from A                     |
 *    key           | The session key                  |
 *    renewal_timer | The key renewal timer            |
 *    ciphertext    | Ciphertext as read from stream   |
 *    cmac          | CMAC as read from stream         |
 */

void unpack_keytosens(void *pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  msg->msgtype = cStream[0];

  // Extract the ciphertext
  for (u_int16_ard i = 0; i < KEYTOSINK_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + i];
  }
  //Extract the hash
  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + (KEYTOSINK_CRYPTSIZE) + i];
  }
  byte_ard plainbuff[KEYTOSINK_CRYPTSIZE];
    
  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, KEYTOSINK_CRYPTSIZE,
             pKeys, (const u_int16_ard*)IV);

  // 1 - nonce
  byte_ard noncetemp[NONCE_SIZE];
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    noncetemp[i] = plainbuff[i];
  }
  msg->nonce = (u_int16_ard)*noncetemp;

  // 2 - key
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->key[i] = plainbuff[NONCE_SIZE + i];
  }
  
  // 3 - timer
  byte_ard timertemp[TIMER_SIZE];
  for (u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    timertemp[i] = plainbuff[NONCE_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*timertemp;
}

/**
 * pack_rekey()
 *
 * Packs a request for rekeying. It is also used to let the sink know that the original
 * session key was delivered, having the MSG typecode 0x31. When used for regular
 * re-keying request, the typecode is set to 0x30.
 *
 * Name:     Msg Code  | Public ID  | Ciphertext                | Cmac   
 * Bytes:    1         | 6 (ID_SIZE)| 16                        | 16
 * Data:     0x31/0x30 |            | Public ID, Nonce, Padding |
 *
 * Total bytecount: 39
 */
void pack_rekey(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  byte_ard* cBuffer = (byte_ard*) pBuffer;
  // MSGTYPE
  if (msg->msgtype == MSG_T_REKEY_HANDSHAKE)
  {
    cBuffer[0] = msg->msgtype;
  }
  else
  {
    msg->msgtype = MSG_T_REKEY_REQUEST;
  }
  
  // T (Public ID)
  for (u_int16_ard i = 0; i < ID_SIZE; i ++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->pID[i];
  }

  // Create the ciphered packet
  // ID
  byte_ard temp[ID_SIZE + NONCE_SIZE];
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  // Nonce
  byte_ard* pNonce = (byte_ard*)&msg->nonce;
  for(u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE + i] = pNonce[i];
  }
  byte_ard cipher_buff[REKEY_CRYPTSIZE];

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff, (ID_SIZE + NONCE_SIZE), AUTOPAD,
             pKeys, (const u_int16_ard*)IV);

  // Stick it in the buffer
  for (u_int16_ard i = 0; i < REKEY_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = cipher_buff[i];
  }

  // CMac
  aesCMac(pCmacKeys, cipher_buff, REKEY_CRYPTSIZE, msg->cmac);
  // Stick it in the buffer
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + REKEY_CRYPTSIZE + i] = msg->cmac[i];
  }
  
}
/**
 * unpack_rekey()
 *
 * Unpacks the re-keying request. Note that pack_rekey() is also used to let the sink know
 * that the original session key was delivered. The MSG typecode used for this is 0x31.
 * Otherwise, regular rekeying requests, use the typecode 0x30.
 *
 * The populated struct:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------------
 *    msgtype       | Message type code                | 0x31 or 0x30
 *    ciphertext    | Ciphertext as read from stream   |
 *    cmac          | CMAC as read from stream         |
 *    pID           | Public ID                        |
 *    nonce         | Nonce                            |
 *
 */
void unpack_rekey(void* pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;
  msg->msgtype = cStream[0];

  // The ID is only extacted from the ciphertext

  // Extract the ciphertext
  for (u_int16_ard i = 0; i < REKEY_CRYPTSIZE; i ++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }
  // Extract the cmac
  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + REKEY_CRYPTSIZE + i];
  }

  // Decipher
  byte_ard plainbuff[REKEY_CRYPTSIZE];
  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, REKEY_CRYPTSIZE,
             pKeys, (const u_int16_ard*)IV);

  // Extract the ID for the ciphertext
  for (u_int16_ard i = 0; i < ID_SIZE; i ++)
  {
    msg->pID[i] = plainbuff[i];
  }
  msg->pID[ID_SIZE] = '\0';

  // Extract the Nonce from the ciphertext
  byte_ard* temp_nonce = (byte_ard*)malloc(NONCE_SIZE);
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    temp_nonce[i] = plainbuff[ID_SIZE + i];
  }
  msg->nonce = (u_int16_ard)*temp_nonce;
  free(temp_nonce);
}

/**
 * pack_newkey()
 *
 * The method intended for the Sink to send the new key to the sensor.
 *
 * Name:   MSG Code | Ciphertext                                                  | CMAC    
 * Bytes:  1        | 32                                                          | 16
 * Data:   0x32     | Public ID, Nonce, Rand key material, Renewal timer, Padding |
 *
 * Total bytecount: 49 bytes
 */

void pack_newkey(struct message* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_REKEY_RESPONSE;
  msg->msgtype = MSG_T_REKEY_RESPONSE;
  
  for(u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + i] = msg->pID[i];
  }

  // Construct the ciphertext
  byte_ard temp[ID_SIZE + NONCE_SIZE + KEY_BYTES + TIMER_SIZE];
  
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    temp[i] = msg->pID[i];
  }
  
  byte_ard* temp_nonce = (byte_ard*)&msg->nonce;
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp[ID_SIZE + i] = temp_nonce[i];
  }
  
  for(u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    temp[ID_SIZE + NONCE_SIZE + i] = msg->rand[i];
  }
  
  byte_ard* temp_timer = (byte_ard*)&msg->renewal_timer;
  for(u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp[ID_SIZE + NONCE_SIZE + KEY_BYTES + i] = temp_timer[i];
  }

  byte_ard cipher_buff[NEWKEY_CRYPTSIZE];

  // Cipher
  CBCEncrypt((void*)temp, (void*)cipher_buff,
             (ID_SIZE+NONCE_SIZE+KEY_BYTES+TIMER_SIZE), AUTOPAD,
             pKeys, (const u_int16_ard*)IV);
  // Stick it in the buffer
  for (u_int16_ard i = 0; i < NEWKEY_CRYPTSIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + i] = cipher_buff[i];
  }

  // CMac
  aesCMac(pCmacKeys, cipher_buff, NEWKEY_CRYPTSIZE, msg->cmac);

  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + ID_SIZE + NEWKEY_CRYPTSIZE + i] = msg->cmac[i];
  }
  
}

/**
 * unpack_newkey()
 *
 * Unpacks the new session key (following rekeying) at the sensor.
 * Populated struct:
 *
 *    Name          | Summary                          | Data
 *    ----------------------------------------------------------------
 *    msgtype       | Message type code                | 0x32
 *    ciphertext    | The ciphertext from stream       |
 *    cmac          | The CMAC from stream             |
 *    pID           | The public ID                    |
 *    nonce         | A nonce from S                   |
 *    rand          | The new key material             |
 *    renewal_timer | The key renewal timer            |
 */

void unpack_newkey(void* pStream, const u_int32_ard* pKeys, struct message* msg)
{
  byte_ard* cStream = (byte_ard*)pStream;

  msg->msgtype = cStream[0];

  // Skip the ID sent in plaintext and grab the cipherstream
  for (u_int32_ard i = 0; i < NEWKEY_CRYPTSIZE; i++)
  {
    msg->ciphertext[i] = cStream[MSGTYPE_SIZE + ID_SIZE + i];
  }

  byte_ard plainbuff[NEWKEY_CRYPTSIZE];

  CBCDecrypt((void*)msg->ciphertext, (void*)plainbuff, NEWKEY_CRYPTSIZE, pKeys,
             (const u_int16_ard*)IV);

  // Cipertext part 1 - ID
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    msg->pID[i] = plainbuff[i];
  }
  
  // Ciphertext part 2 - Nonce
  byte_ard* temp_nonce = (byte_ard*)malloc(NONCE_SIZE);
  for (u_int16_ard i = 0; i < NONCE_SIZE; i++)
  {
    temp_nonce[i] = plainbuff[ID_SIZE + i];
  }
  msg->nonce = (u_int16_ard)*temp_nonce;
  free(temp_nonce);

  // Ciphertext part 3 - Random
  for (u_int16_ard i = 0; i < KEY_BYTES; i++)
  {
    msg->rand[i] = plainbuff[ID_SIZE + NONCE_SIZE + i];
  }

  // Ciphertext part 4 - Timer
  byte_ard* temp_timer = (byte_ard*)malloc(TIMER_SIZE);
  for(u_int16_ard i = 0; i < TIMER_SIZE; i++)
  {
    temp_timer[i] = plainbuff[ID_SIZE + NONCE_SIZE + KEY_BYTES + i];
  }
  msg->renewal_timer = (u_int32_ard)*temp_timer;
  free(temp_timer);

  for (u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    msg->cmac[i] = cStream[MSGTYPE_SIZE + ID_SIZE + NEWKEY_CRYPTSIZE + i];
  }
}

/**
 * pack_data()
 * 
 * Packs the measurment data collected by the tsensor. Right now,
 * data is assumed to reside inside a byte_ard array.
 *
 * Name:    MSG Code | Ciphertext                                            | Cmac 
 * Bytes:   1        | ID: 6, Msg Time: 4, Buffer length: 1, Data: Varies    | 
 * Data:    0x01     | Public ID, Msg Time, Buffer length, Data                   
 */

void pack_data(struct data* msg, const u_int32_ard* pKeys, const u_int32_ard* pCmacKeys, void* pBuffer)
{
  byte_ard* cBuffer = (byte_ard*)pBuffer;
  cBuffer[0] = MSG_T_DATA_SEND;

  /* NOTE: Here we use integer division to figure out how many blocks
   * we need for the ciphertext. In future versions every method in
   * the Tsense protocol will use this method instead of the retarded
   * constants.
   *
   * The +1 (in plainsize) is for the buffer length on the stream
   */
  
  u_int16_ard plainsize = ID_SIZE + MSGTIME_SIZE + 1 + (u_int16_ard) msg->buff_len;
  u_int16_ard cryptsize = (1 + (plainsize/BLOCK_BYTE_SIZE)) * BLOCK_BYTE_SIZE;  
  
  /* Malloc is needed because we don't know the exact size
   */
  byte_ard* plaintext = (byte_ard*)malloc(plainsize);

  // Populate plaintext.
  for (u_int16_ard i = 0; i < ID_SIZE; i++)
  {
    plaintext[i] = msg->id[i];
  }
  byte_ard* temp_msgtime = (byte_ard*)&msg->msgtime;
  for (u_int16_ard i = 0; i < MSGTIME_SIZE; i++)
  {
    plaintext[ID_SIZE + i] = temp_msgtime[i];
  }
  // One byte - no loop
  plaintext[ID_SIZE + MSGTIME_SIZE] = msg->buff_len;

  // Data
  for(u_int16_ard i = 0; i < (u_int16_ard)msg->buff_len; i++)
  {
    plaintext[ID_SIZE + MSGTIME_SIZE + 1 + i] = msg->data[i];
  }


  byte_ard cipher_buff[cryptsize];

  CBCEncrypt((void*)plaintext, (void*)cipher_buff, plainsize, AUTOPAD,
             pKeys, (const u_int16_ard*)IV);
  free(plaintext);
  aesCMac(pCmacKeys, cipher_buff, cryptsize, msg->cmac);

  // Stick it in the buffer
  for(u_int16_ard i = 0; i < cryptsize; i++)
  {
    cBuffer[MSGTYPE_SIZE + i] = cipher_buff[i];
  }

  for(u_int16_ard i = 0; i < BLOCK_BYTE_SIZE; i++)
  {
    cBuffer[MSGTYPE_SIZE + cryptsize + i] = msg->cmac[i];
  }
}

