
"""
Python script to manage burning devie dependent data onto a tsensor EEPROM
"""

__product_name__ = "tsburner.py"
__author__ = "Kristjan V. Jonsson"
__version__ = "0.1.1"

import os
import sys
import getopt
import string
import logging
import logging.handlers
from time import * # For the timestamp

#
# This is the header string in C code.
#
headerstr = '''
#include <EEPROM.h>
#include "../aes_tables.h"
#include "../edevdata.h"
#include "WProgram.h"

#define LED_STATUS          2
#define LED_SIGNAL_1        3
#define LED_SIGNAL_2        4
#define LED_SIGNAL_3        5
#define LED_SIGNAL_4        6

'''

#
# This is the main C program body.
#
mainprogstr = '''
void setup(void)
{
  // Set pinMode of digital pins to output
  pinMode(LED_STATUS,OUTPUT); 
  pinMode(LED_SIGNAL_1,OUTPUT);
  pinMode(LED_SIGNAL_2,OUTPUT);
  pinMode(LED_SIGNAL_3,OUTPUT);
  pinMode(LED_SIGNAL_4,OUTPUT);
    
  Serial.begin(9600);
  Serial.flush();

  digitalWrite(LED_STATUS,LOW);
  digitalWrite(LED_SIGNAL_1,LOW);
  digitalWrite(LED_SIGNAL_2,LOW);
  digitalWrite(LED_SIGNAL_3,LOW);
  digitalWrite(LED_SIGNAL_4,LOW);  
  
  delay(1000);
  
  // Set all status LEDs to indicate ongoing EEPROM programming
  digitalWrite(LED_STATUS,HIGH);
  digitalWrite(LED_SIGNAL_1,HIGH);
  digitalWrite(LED_SIGNAL_2,HIGH);
  digitalWrite(LED_SIGNAL_3,HIGH);
  digitalWrite(LED_SIGNAL_4,HIGH);  
    
  // Write AES sbox lookup table
  for( int i=0; i<S_TABLE_LEN; i++)
    EEPROM.write(S_TABLE_START+i,sbox[i]);

  // Write AES inverse sbox lookup table    
  for( int i=0; i<IS_TABLE_LEN; i++)
    EEPROM.write(IS_TABLE_START+i,isbox[i]);
  
  // Write the AES round constant table
  for( int i=0; i<RCON_TABLE_LEN; i++)
    EEPROM.write(RCON_TABLE_START+i,Rcon[i]);
  
  // Write the public device ID
  for( int i=0; i<DEV_ID_LEN; i++ )
    EEPROM.write( i+DEV_DATA_START+DEV_ID_START, devId[i] );
    
  // Write the private device ID -- private key
  for( int i=0; i<DEV_KEY_LEN; i++ )
    EEPROM.write( i+DEV_DATA_START+DEV_KEY_START, masterKey[i] );
 
  // Write manufacturer defined data
  for( int i=0; i<DEV_MAN_NAME_LEN; i++ )
	EEPROM.write( i+DEV_DATA_START+DEV_MAN_NAME_START, manName[i] );
  for( int i=0; i<DEV_MODEL_NAME_LEN; i++ )
	EEPROM.write( i+DEV_DATA_START+DEV_MODEL_NAME_START, manModel[i] );
  for( int i=0; i<DEV_SERIAL_NO_LEN; i++ )
	EEPROM.write( i+DEV_DATA_START+DEV_SERIAL_NO_START, manSerial[i] );
  for( int i=0; i<DEV_MAN_DATE_LEN; i++ )
	EEPROM.write( i+DEV_DATA_START+DEV_MAN_DATE_START, manDate[i] );
}

// Blink all LEDs after flashing the EEPROM is done
void loop(void)
{
  static bool blinkState=false;
  blinkState = !blinkState;  
  digitalWrite(LED_STATUS,blinkState);
  digitalWrite(LED_SIGNAL_1,blinkState);
  digitalWrite(LED_SIGNAL_2,blinkState);
  digitalWrite(LED_SIGNAL_3,blinkState);
  digitalWrite(LED_SIGNAL_4,blinkState);      
  delay(5000);  
}

'''

class Usage(Exception):
	"""
	Usage exception class
	"""
	def __init__(self, msg):
		self.msg = msg

def write_padded(string,length):
	if len(string)>length: return string[:length]
	ret=string
	for i in range(len(string),length):	ret+=" "
	return ret

def gen_file_header(f):
	"""
	Generate the timestamp for the C program file.
	"""
	f.write('/*\nAutogenerated file to flash a tsensor device\n%s\n*/\n\n' % ctime(time()))

def public_id(f,manid,devid,logger):
	"""
	Write the public id byte array to the file
	"""
	
	manid_lb = manid & 0xFF
	manid_ub = ( manid >> 8 ) & 0xFF

	devid_llb = devid & 0xFF
	devid_lub = ( devid >> 8 ) & 0xFF
	devid_ulb = ( devid >> 16 ) & 0xFF
	devid_uub = ( devid >> 24 ) & 0xFF
	
	f.write("\n\n")
	f.write('unsigned char devId[6] = {0x%.2x,0x%.2x,0x%.2x,0x%.2x,0x%.2x,0x%.2x};\n' % (manid_ub,manid_lb,devid_uub,devid_ulb,devid_lub,devid_llb))

	logger.info("Public ID: 0x%.2x 0x%.2x -- 0x%.2x 0x%.2x 0x%.2x 0x%.2x" % (manid_ub,manid_lb,devid_uub,devid_ulb,devid_lub,devid_llb))

def private_id(f,key,logger):
	"""
	Write the private id (private key) to the file.
	"""
	key = key.strip("{} \r\n\t");
	f.write("\n\n")
	f.write('unsigned char masterKey[16] = {%s};\n' % key)
	
	logger.info("Private ID: %s" % key )

def man_info(f,name,model,serial,date,logger):
	"""
	Write the manufacturer info to the file
	"""
	f.write("\n\n")
	f.write('char manName[]  =  {"%s"};\n' % write_padded(name,16));
	f.write('char manModel[] =  {"%s"};\n' % write_padded(model,16));
	f.write('char manSerial[] = {"%s"};\n' % write_padded(serial,16));
	f.write('char manDate[]  =  {"%s"};\n' % write_padded(date,16));

	logger.info("Manufacturer info # name: %s, model: %s, serial: %s, date: %s" % (name,model,serial,date))

def get_new_private_id():
	f = os.popen('../aes_crypt/tools/generatekey -c') # TODO: Hardcoded path bit messy
	l = f.readlines()
	keystr=""
	for c in l:
		c = c.strip("{} \r\n\t")
		keystr+=c
	f.close()
	return keystr

def main(argv=None):

	idinfo=[]
	maninfo=[]
	output_file=""
	
	if argv is None:
		argv = sys.argv

		# TODO: If we want the client to be more flexible, we can add all sorts of cmd line
		# config parameters here. 
		try:
			try:
				opts, args = getopt.getopt(argv[1:], "hvi:m:o:", ["help","version","id-information=","manufacturer-information=","output-file="])
			except getopt.error, msg:
				raise Usage(msg)
		except Usage, err:
			print >>sys.stderr, err.msg
			print >>sys.stderr, "for help use --help"
			return 2
		for o, a in opts:
			if o in ("-h", "--help"):
				print __doc__
				sys.exit(0)
			if o in ("-v", "--version"):
				print __product_name__,__version__
				sys.exit(0)
			if o in ("-i", "--id-information"):
				a=a.strip("[]")				
				idinfo=a.split(",")
			if o in ("-m", "--manufacturer-information"):
				a=a.strip("[]")				
				maninfo=a.split(",")
			if o in ("-o", "--output-file"):
				output_file=a

	print "\n\ntsclient"
	print "========\n"

	try:
		if output_file=="": 
			raise Exception("No output file specified")
		if idinfo==[]:
			raise Exception("No identification information specified")
		if maninfo==[]:
			raise Exception("No manufacturer information specified")
	except Exception, err:
		print >>sys.stderr,"Error: %s.\nExiting.\n\n" % err
		sys.exit(-1)

	print "\toutput file:\t%s" % output_file
	print "\tid (public,private):\t%s" % idinfo
	print "\tmanufacturer info:\t%s" % maninfo
	print "\n\n"

	# Set the logger log level	
	log_level = logging.DEBUG

	# Initialize the logger
	logger = logging.getLogger("tspcgen")
	logger.setLevel(log_level)
	fh = logging.handlers.RotatingFileHandler("tspcgen.log", mode="a", maxBytes=1024*1024, backupCount=10)
	ff = logging.Formatter("%(asctime)s:%(levelname)s:%(name)s: %(message)s")		
	fh.setFormatter(ff)
	sh = logging.StreamHandler()
	sh.setLevel(log_level)
	sf = logging.Formatter("%(asctime)-10s%(levelname)-10s%(name)-30s%(message)s","%H:%M:%S")
	sh.setFormatter(sf)
	logger.addHandler(fh)
	logger.addHandler(sh)

	# Log a start notice
	logger.info("Starting tsensor id programming procedure. Generating programming code.")

	f = open(output_file,"w")

	logname = "man_%s.log" % maninfo[0]
	logrecord=[]
	serial=1
	try:
		logfile = open(logname,"r")
		l=logfile.readline()
		lastline=""
		while l!="":
			lastline=l
			l=logfile.readline()
		logfile.close()
		logrecord = lastline.split(";")
		lastserial = string.atoi(logrecord[0])
		serial = lastserial+1
	except IOError,err:
		print "Error reading log file: %s. Using default values.",err

#	t=time()
	datestr = strftime("%Y.%m.%d-%H:%M")   #ctime(time()) # TODO: MORE COMPACT DATE STRING
	gen_file_header(f)
	f.write(headerstr)
	try:
		public_id(f,string.atoi(idinfo[0]),string.atoi(idinfo[1]),logger)
	except Exception,err:
		print >>sys.stderr,"Conversion error: %s" % err
		sys.exit(-1)
	if len(idinfo)>2 and idinfo[2]!="": # Use private key on command line
		pk = idinfo[2]
	else:
		pk = get_new_private_id()  # Generate new private key
		idinfo.append(pk)
	private_id(f,pk,logger)
	man_info(f,maninfo[0],maninfo[1],"%d" % serial,datestr,logger)
	maninfo.append("%d" % serial)
	maninfo.append(datestr)
	f.write(mainprogstr)
	logger.info("Done generating programming code. Output to %s" % output_file)

	try:
		logfile = open(logname,"a")
		logfile.write("%s;'%s';'%s';'%s'\n" % (serial,datestr,idinfo,maninfo))
		logfile.close()
		f.close()
	except Exception,err:
		print "Error committing to log:",err


if __name__ == "__main__":
	sys.exit(main())
