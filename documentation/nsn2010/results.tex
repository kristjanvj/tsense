
\chapter{Results}
\label{sec:results}

Our work began with construction of small prototypes, in order to get to grips with the Duemilanove and the Arduino development environment. Although we hit some initial problems, the experience of working with the Arduino system was overall a pleasant one. The basic system design decisions were then discussed in the group, which settled on the fully symmetric crypto approach. We then proceeded to code and test the cryptographic primitives on the supported platforms. The cryptographic protocols were designed in parallel with the code development. Once all the ducks were in a row, we proceeded to code the protocols in a multi-platform library, again for minimum coding effort and maximum maintainability. The final step was to integrate and test the system as a whole. We will describe our results in this section.

\section{Verification of cryptographic primitives}
\label{sec:verification-of-cryptographic-primitives}

Unit testing of cryptographic primitives and the various system components was used throughout the software development process on all supported platforms:
\begin{itemize}
\item Arduino Duemilanovae with Atmel ATmega328 processor, used for tsensor development
\item Laptops with Intel and AMD 32- and 64 bit processors, running Ubuntu Linux and OS/X used for client, sink and authentication server development.
\item Virtual machines, running Ubuntu Linux, used for sink and authentication server development and testing.
\end{itemize}
%
Tests included the following:
%
\begin{itemize}
\item Unit tests of the AES block cipher (encryption and decryption) using available test vectors, e.g.\ the key expansion and encryption test vectors from the FIPS \shortcite{fips-197-2001} document and the AES known answer test (KAT)\footnote{\url{http://csrc.nist.gov/groups/STM/cavp/documents/aes/KAT_AES.zip}} dataset.
\item Unit tests of the CBC-mode encryption and decryption on all supported platforms and for plaintexts of various lengths, from one block (16-bytes) to several blocks in length. The bulk of our testing consisted of checking the consistency of encryption and subsequent decryption of randomly generated data chunks of various lengths, from sub-block size to several block sizes. We tested both data of even block lengths and partially filled blocks to reveal potential padding issues.
\item Unit tests of the CMAC authentication algorithm, using randomly generated data as well as the test cases provided by \shortciteA{rfc-4494-song-2006}.
\item Unit testing data provider (test client), which can replace the sensor/client pair in testing against sink and authentication servers. This module is written in C and implements the protocol code as the tsensor device.
\end{itemize}
All unit tests are included in our open source implementation at \url{http://code.google.com/p/tsense}. We refer to the publicly available code for further verification of our implemented primitives.

\section{Performance of cryptographic primitives}

\subsection{AES encryption and decryption in CBC mode on Arduino}
\label{sec:aes-cbc-performance-arduino}

The precise timing instruction \texttt{micros()}\footnote{\url{http://arduino.cc/en/Reference/Micros}} on the Arduino was used to time successive encryption and decryption operations on randomly generated data of one to several blocks in length. An Arduino Duemilanovae board with an ATmega328 running at 16MHz was used for the test. Briefly, the results were that our implementation achieves an average throughput of 1213 blocks/sec for encryption and 592 blocks/sec for decryption on the Arduino. The worse performance of the decryption operation is most likely due to the more complex mixColumns transformations required for decryption. Future optimizations will address this.

Given that the data stream from the sensors is not continuous and each packet is rather short, we conclude that the throughput of the AES encryption algorithm is quite sufficient for our project.

\subsubsection*{Comparison with the XTEA block cipher}

We did a quick comparison test of the XTEA \shortcite{needham1997} block cipher, based on the reference algorithm given on \url{http://en.wikipedia.org/wiki/XTEA}. XTEA was designed to be a very efficient block cipher, especially on resource constrained systems. The entire implementation takes about 16 lines of C code. It is interesting to see how this light-weight cipher compares in performance with the more secure AES. The test was performed in the same manner as that for our AES implementation. The results were a throughput of 1316 blocks/sec for encryption and 1574 blocks/sec for decryption. The recommended 32 rounds were used for both operations. We conclude that our AES implementation compares favorably with the XTEA one, given that the XTEA test operated in the slightly simpler ECB mode and has a shorter block length of 64 bits. Accounting for the differing block length shows a very acceptable throughput for our AES implementation, as shown in Table~\ref{tab:aes-xtea-comparison}.

\begin{table}[h]
\begin{center}
\begin{tabular}{|c|r|r|r|r|}
\hline  & Encrypt & Encrypt & Decrypt & Decrypt \\
\hline  & (blocks/sec) & (Kbytes/sec) & (blocks/sec) & (Kbytes/sec) \\ 
\hline AES & 1213 & 18.9 & 592 & 9.3 \\ 
\hline XTEA & 1316 & 10.3 & 1574 & 12.1 \\ 
\hline 
\end{tabular}
\end{center}
\caption{Comparison of AES and XTEA performance on the Arduino platform (ATmega328 at 16MHz). Note that AES has a block length of 16 bytes compared to the shorter 8 byte block length of XTEA.}
\label{tab:aes-xtea-comparison}
\end{table} 

\subsection{AES encryption and decryption in CBC mode on Intel-based platforms}

The same code as timed in Section~\ref{sec:aes-cbc-performance-arduino} was compiled in a test framework on a 32-bit Intel laptop with a Centrino Dual CPU, each core running at 1GHz, with 4MB L2 cache. Only one core of the CPU was used in the test. The test machine ran Ubuntu Linux 9.10 (kernel 2.6.31-22). Chunks of random data, from 1 to 256 blocks at 16 bytes each, were generated, encrypted and decrypted. The encryption and decryption operations were timed using the C \texttt{gettimeofday} function, each measurement averaged over several repetitions. The results were that our implementation achieves roughly 2.7 Mbytes/sec. This result was also verified using the Unix \texttt{time}\footnote{\url{http://unixhelp.ed.ac.uk/CGI/man-cgi?time}} utility.

Our test servers achieved throughput of roughly 4.3 MBytes/sec running the same test. The test servers are 32-bit virtual machines running Ubuntu Linux 10.04.1 LTS (2.6.32-24). The single CPU runs at 1995 MHz and has a 4MB L2 cache.

The AES implementation used in this project is byte oriented and close to the original published pseudocode \shortcite{fips-197-2001}. A reference implementation, written by the supervisor for another project, achieves roughly four times the throughput using the more efficient 32-bit table-based algorithm, described by \shortciteA{daemen1999}. Updating our present library to utilize such features is reserved for future work.

We regard these tests as strictly "wallclock" indicators, but nevertheless useful for evaluating the performance of our implementation.
%
Our conclusion is that the AES algorithm on a typical sink platform can achieve throughput which is orders of magnitude greater than that of the sensors, meaning a single sink server can service several hundred continuously transmitting sensors, especially factoring in the bursty nature of the communications.

\section{\textit{tsensor} memory footprint}

Code size is quite important on a small device, such as the ATmega controller. Our compiled tsensor code binary is currently 14.5 KB of the total available program memory (flash) of 32KB. The AES test code binary, used for the timing tests in Section~\ref{sec:aes-cbc-performance-arduino}, is 11.2 KB, while the XTEA test code binary is 6.7 KB. Most of the difference in binary size between the two tests is due to the more complex AES algorithm. However, a size difference of less than factor two is quite acceptable, in our opinion, for the more secure AES block cipher. Note also that our full tsensor implementation with the AES block cipher currently occupies less than 50\% of the available program memory of the ATmega328, which means that more complex cryptographic primitives, such as public key crypto, can most likely be implemented in future versions.

The RAM memory use is even more critical, as discussed earlier. Unfortunately, there are currently no methods to accurately measure the RAM use in the current Arduino library. However, we can estimate the amount of free RAM by the value of the heap and stack pointers. An serial API command for reporting the free RAM is included in the current tsensor version. At startup, the free RAM is reported as 1638 bytes, some of which is used by the controller itself and the Arduino bootloader. After full initialization, key expansion and allocation of a 20 byte measurement buffer, the available RAM is reported as 734 bytes. 

RAM use can be improved in our current implementation, for example by expanding keys only as needed -- AES-128 uses a key schedule of ten 16-byte keys, derived from the original 16 byte one. Currently, we store the session keys (encryption and authentication) expanded, which requires 320 bytes of RAM. Expanding the seldom used session key on demand would therefore free up considerable RAM. Constants for key derivation can also be moved into the EEPROM, which still has considerable free space.

\section{System verification}

We refer to our earlier discussion in Section~\ref{sec:verification-of-cryptographic-primitives} on the unit testing of the cryptographic primitives -- the building blocks of the protocols. Regarding the correctness of our protocols, we refer to the publicly available code at \url{http://code.google.com/p/tsense} and the analysis of Section~\ref{sec:crypto-protocol-analysis}.

The daemons (sink and authentication servers) were tested on 32-bit Linux and 64-bit OS X/BSD platforms, with the main test environment being 32 bit Linux virtual machines, running Ubuntu 10.04 and the 2.6.32 kernel. Both the Linux and OS X/BSD machines used Intel CPUs and neither the daemons nor the encryption or network libraries they use were tested on machines with big-endian processors. Doing so might reveal bugs in the networking and encryption libraries. 

The implementation of the cryptographic protocols -- authentication, key-exchange and data transfer -- was done on a test bed system, using a setup similar to the one shown in Figure~\ref{fig:sys-overview}. Laptops running Linux and a MacBook running OS X served as hosts (clients) for Duemilanove-based tsensors. Two virtual machines, running Ubuntu 10.04 LTS (kernel 2.6.32) served as sink and authentication servers. The clients used DHCP to obtain dynamic network addresses, while the two servers had fixed IPs. The sensor board was USB-connected to its host (client).

The protocols were tested individually at first and then combined. In summary, we were successful in getting the whole system up and running, albeit under fairly well controlled circumstances. Notably, handling of abnormal and unexpected events is lacking in the current version. However, we believe we have shown the feasibility of our implementation in a proof-of-concept setting.

\section{Soundness of the cryptographic protocols}
\label{sec:crypto-protocol-analysis}

The following discussion is not intended to be a formal cryptographic analysis of the protocols, but rather an informal discussion about their security properties. More formal analysis is reserved for future work.

The code for the protocol is publicly available at \url{http://code.google.com/p/tsense}, satisfying Kerckhoffs' principle that ``a cryptosystem should be secure even if everything about the system is public knowledge''. The code was also written with security in mind, aiming to leave as few vulnerabilities as possible. Great care was taken to prevent the possibilities of buffer overflow, and because of the technical nature of the protocol itself, format-string attacks are not possible. Although this aims to provide local security and not directly security over the data, the system can only be considered secure as long as all parts are secure. If remote code execution were possible on either the tsensor, tssinkd or tsauthd --- then an attacker could be able to alter data. 
%If a potential attacker has the device public ID (16-byte AES key) then the system is compromised for that particular sensor node but it will not have any effect on other nodes.

Since the cryptography in the protocol is based on AES it can only be considered secure as long as AES is considered secure. At the time of writing (September 2010) there are no known attacks against the AES cipher, except reduced round (reduced strength) variants, e.g.\ the super-SBox attack against 8-round AES-128 \shortcite{gilbert2009}. We are using the full 10-round AES-128, giving considerable security margin. 
%\textbf{However, we have not considered side channel attacks, such as cache timing \cite{} and power analysis \cite{}.} We reserve hardening against such attacks for future work.
Further, the protocols are independent of the actual cipher used, meaning that higher strength AES or a completely different block cipher can be easily substituted.

The security of the entire system hinges on the secrecy of the private device key -- the permanent keys burned onto each tsensor device. Extracting a single permanent key does compromise a single device, but not the entire system, since the keys are (with high probability) unique per device. However, recovering a limited amount of private device keys does give an attacker complete control over the corresponding identities. We assume key recovery is hard due to physical hardening of the device (tamper-proofing) and the serial protocol itself, giving an acceptable security level for the entire system and graceful degradation (rather than complete collapse) in case of limited number of key recoveries.

Confidentiality is provided in by using strong encryption. Additionally, bilateral implicit key authentication \shortcite[pp.498]{menezes1996} is used in all protocols; correct decryption of shared, but secret, information, e.g.\ nonces, is an implicit proof that both parties hold the pairwise shared private key.

Authenticity is provided by applying an MAC to all messages, ensuring that message alterations can (with high probability) be detected by the recipients. The MAC keys are derived from the encryption keys, observing the principle that a key should never be re-used for two different purposes.
Again, this assumption only holds as long as the attacker does not have knowledge over the encryption keys. 

Key derivation by means of an cryptographically secure one-way function\footnote{We assume (without proof at this point) that the CMAC function has this property.}, ensures that the derived key is statistically independent from the one it was derived from. Hashing a random-looking number, in our case by the equivalent of a keyed hash function, produces an equally random-looking result. The cryptographic properties of the one-way function imply that there should be no correlations between the input and output, resulting in statistically independent derived keys.

%The derived MAC keys leak no information about the underlying encryption keys, based on the presumption of the one-wayness of the CMAC function. Random looking key material hashed with any key, even publicly available, results in a random-looking string of bytes. A cryptographically secure pre-image resistant hash function ensures the master key (key material) is secure, even though the derived key is compromised. We assume this property holds when using the CMAC function for key derivation. Formal proof is reserved for future work.

Cryptographic keys degrade (theoretically), however slightly, by every use. Limiting the use of the permanent device secret key to only authentication and session key exchange helps to preserve the security lifetime of the sensor device. Similarly, limiting the use of the session key to strictly re-keying helps to preserve its integrity. However, if an attacker would get hold of the current session key, he can get hold of all future session keys as well, since the new key-material is encrypted with a key derived from the current session key before it is sent. 
%
Strictly limiting the lifetime of transport encryption and authentication keys further helps to preserve the integrity of the system.

We have discovered some potential vulnerabilities in our present version of the protocol, which will be considered in future work. For example, adding the public device ID to the encrypted key-to-sink payload would give the tsensor two factors to identify the authentication server, instead of just one (the nonce). More "entropy" has to be added to the data transfer protocol, perhaps in the form of a nonce or dummy random number of several bytes. A promising approach is to add an sink to sensor ACK message for each data update (the current protocol is strictly fire-and-forget) which would carry a next-round data transfer nonce. This would also allow the sink to detect and respond to  missing data updates, for example ones dropped by malicious clients. 

\section{Cost of materials and production sensor size}

We base our sensor prototype on an Arduino Duemlianove experimentation board, mainly for the convenience of programming the ATmega328 in such an environment, rather than having to use a separate programmer. The cost of this board is \$29.95 (+ shipping and import costs) from \url{http://www.sparkfun.com} in September 2010. An Atmel ATmega328 is available for \$4.40 in quantities of 100+ from Sparkfun, but this would require custom circuit boards and some additional support hardware. The cost of sensors varies according to their sophistication, but the NTC thermistor and photoresistor used in our project cost less than \$2 a piece. A reasonable estimated price for an assembled and tamper-proof tsensor is less than \$20 in quantities using our demonstration sensors. 

Production sensors would use a much smaller custom PCB and a surface mount version of the processor. Estimated size for a production unit is less than 2x2 cm, using a surface mount ATmega328 package. Even smaller sizes can be achieved using custom ICs. The size of the final package depends on the type of sensor and the hardening to be applied, but we can conclude that it is certainly practical to manufacture a reasonably small fully enclosed tsensor. 

Our conclusions are that an ATmega-based tsensor is a relatively cheap and small unit, which fulfills our initial goal.

