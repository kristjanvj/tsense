
\chapter{Introduction}
\label{sec:intro}

Secure gathering and aggregation of measurements is a vital component in most modern networked systems, such as large computer networks, power grid monitoring and control, and industrial SCADA systems. The size and complexity of modern networked measurement systems raises questions regarding scalability, dependability and security. Security and trustworthiness of the collected data is in our opinion of particular interest in such systems, given that critical decisions, e.g.\ regarding resource allocation, failure response and customer billing are based on reliable information; bad information can easily render a system useless, or worse, cause damage due to improper management decisions.

In this work, we address one facet of measurement system security. We explore the concept of a \textit{trusted sensor} -- a small self-contained device with very limited communications capabilities. In essence, we explore the issues and challenges involved in securing measured data at the earliest possible point in a measurement system -- at the sensors themselves.
%
Our proof-of-concept prototype, \textit{tsensor}, consists of a small embedded microcontroller, a simple sensor array\footnote{The prototype uses simple resistance-based measurement devices, a NTC thermistor and photoresistor. A wide range of analog as well as digital one- and two-wire sensors are available and can be used for more sophisticated measurements.} and basic serial port communications. A production unit would be embedded in a permanently sealed and tamper-proof package, ensuring that manipulation of the unit, including extraction of cryptographic keys, would be infeasible. 
%In contrast, our current prototype is anything but tamperproof, although we demonstrate the feasibility of the architecture.
The tsensor is attached to a host system via an USB port, transforming that host, although inherently untrusted, into a trustworthy source of measurements for a networked monitoring system.

The goal of this project is to explore the issues involved in providing (within computational bounds) end-to-end integrity and confidentiality guarantees between sensor and sink (the recipient of the measurements). These issues include implementing and running cryptographic protocols on resource constrained hardware and exploring the minimal required support infrastructure for a complete working secure measurement system.

\section*{Security goals and adversarial modeling}
\label{sec:sec-goals}

We use a client/server model, in which clients are pairs of tsensors and untrusted end-systems of some sort and servers are measurement sink servers. Sink servers and tsensors are implicitly trusted: tsensors by the embedded cryptographic keys and assumed tamperproofness, and the sink servers by the assumption of direct control and hardening. Therefore, the clients, the general purpose end-user systems, are the sole corruptible node type in the system.
%
We focus on \textit{integrity}, and to a lesser extent \textit{confidentiality} issues, in the classic CIA\footnote{Confidentiality, Integrity and Availability.} trilogy of computer security. We neglect \textit{availability} issues, since we focus on stealthy data modification attacks, rather than the generally "noisy" availability ones, such as denial-of-service attacks. For simplification, we will talk about a single adversary corrupting some fraction of the client population.

We consider insider attackers\footnote{Insider attackers are ones which are participants in the system. Insiders have knowledge of the communications protocols used and may attempt to modify them to obtain an advantage. Furthermore, insiders have access to a subset of the cryptographic key material in the system, at minimum their own private keys.}, that is, the end-systems corrupted by our adversary. Outsider attackers, both active and passive, are excluded by the encrypted and authenticated tsensor/sink communications. We assume stealthy adversaries \shortcite{przydatek2003}, that is, ones which seek to modify the aggregate computed by the sink in such a manner that they remain undetected for extended periods of time. The adversary can coordinate the actions of the clients under its control, that is, we assume colluding corrupted entities.

We assume the client, even if corrupted, will always communicate with a single sink, and further, its correct designated sink. That is, a corrupted client will never try to divert communications to an entity controlled by the adversary. The rationale behind this assumption is that the goal of the adversary in our model is to stealthily influence the aggregate measurement, not to "steal" the individual readings or disrupt the monitoring system itself.

To summarize, the adversarial goal is to corrupt some fraction of the clients such that it can stealthily influence the final aggregate of the collected measurements. The security requirements are that \underline{if} a client delivers a result produced by a trusted sensor, the corresponding sink can ascertain (within computational bounds) that the results are authentic. Optionally, we guarantee (within computational bounds) that \underline{if} readings are delivered to the sink, they are confidential with respect to any third party, sensors, clients or any intermediary nodes.

%%\subsection*{The role of encryption}
%%
%%Our main goal is to effectively deny an adversary the possibility of modifying messages, which can be effectively addressed by applying message authentication codes (MACs) or digital signatures. We use MACs in our system, as will be discussed later on. Authenticity does not imply confidentiality as MAC authenticated messages are commonly sent in plaintext. However, we assume encryption and MAC as our standard mode of operation. 
%%%This does not buy any added security in terms of the GWW example, but may do so for other applications. Encryption ensures confidentiality, which may be important for some applications. Even more importantly, it helps to deny the adversary the opportunity to selectively drop and forward measurements to advance its own stealthy goals. 
%%
%%We can deny the adversary the possibility to modify messages by the application of MACs. However, measurement bias can be introduced by dropping messages, that is simulating crash failures. Crash failures are a fact of life in any distributed system and do not necessarily indicate any malicious behavior. Selective dropping can therefore be a reasonably effective and stealthy method of manipulating the aggregate results. Encryption means that the adversary is partially blinded, which limits his options to make rational decisions regarding which messages to forward or drop. 
%%%This of course assumes that the adversary does not have direct knowledge of the measured quantity. This is in general not the case in an end-to-end client/server system but comes into play in a distributed aggregation system, which is the future goal of this system.

\section{Contribution}

The contributions of this work are the following:
\begin{itemize}
\item Multi-platform implementation of the industry standard AES encryption algorithm, executable on 32- and 64-bit Intel/AMD systems under Linux and OS X/BSD as well as on the 8-bit Atmel ATmega328 microprocessor. The block cipher building block was used to implement CBC-mode encryption and decryption, and CMAC authentication. A cryptographic library for symmetric encryption and authentication is part of our codebase for the TSense project.
\item Development of a trusted sensor prototype, for use in a comprehensive client/server based secure measurement system with a trusted third party service. The proof-of-concept system includes:
\begin{itemize}
\item a trusted sensor prototype -- \textit{tsensor} -- based on an Arduino Duemlianove\footnote{\url{http://http://arduino.cc/en/Main/Hardware}} with an Atmel ATmega328 embedded microprocessor.
\item sink server software for collecting and processing measurements received from a number of tsensors.
\item authentication server software for strong identification of tsensors (the trusted third party).
\item a set of cryptographic protocols for authentication, key exchange and data transfer, tying all components together into a comprehensive measurement system.
\end{itemize}
\end{itemize}

All the tsense code, including sensor, supporting infrastructure and utilities, is open-source and maintained at \url{http://code.google.com/p/tsense}. 




